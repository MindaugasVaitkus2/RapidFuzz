{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rapid fuzzy string matching using the Levenshtein Distance RapidFuzz is a fast string matching library for Python and C++, which is using the string similarity calculations from FuzzyWuzzy . However there are two aspects that set RapidFuzz apart from FuzzyWuzzy: 1) It is MIT licensed so it can be used whichever License you might want to choose for your project, while you're forced to adopt the GPL license when using FuzzyWuzzy 2) It is mostly written in C++ and on top of this comes with a lot of Algorithmic improvements to make string matching even faster, while still providing the same results. More details on these performance improvements in form of benchmarks can be found here","title":"Home"},{"location":"benchmarks/","text":"Benchmarks \u00b6 To compare the speed of FuzzyWuzzy and RapidFuzz the Benchmark of FuzzyWuzzy is used. Therefore the Benchmark is always executed for FuzzyWuzzy and RapidFuzz. Afterwards a ratio between the runtime of both results is calculated. The benchmark can be found here . The results of the benchmarks are visualised below. fuzz.ratio \u00b6 fuzz.partial_ratio \u00b6 fuzz.WRatio \u00b6 process.extract \u00b6 process.extractOne \u00b6","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"To compare the speed of FuzzyWuzzy and RapidFuzz the Benchmark of FuzzyWuzzy is used. Therefore the Benchmark is always executed for FuzzyWuzzy and RapidFuzz. Afterwards a ratio between the runtime of both results is calculated. The benchmark can be found here . The results of the benchmarks are visualised below.","title":"Benchmarks"},{"location":"benchmarks/#fuzzratio","text":"","title":"fuzz.ratio"},{"location":"benchmarks/#fuzzpartial_ratio","text":"","title":"fuzz.partial_ratio"},{"location":"benchmarks/#fuzzwratio","text":"","title":"fuzz.WRatio"},{"location":"benchmarks/#processextract","text":"","title":"process.extract"},{"location":"benchmarks/#processextractone","text":"","title":"process.extractOne"},{"location":"contributing/","text":"Contributing \u00b6 Interested in contributing to RapidFuzz? Want to report a bug? Before you do, please read the following guidelines. Submission context \u00b6 Got a question or problem? \u00b6 For quick questions there's no need to open an issue as you can reach us on gitter.im . Found a bug? \u00b6 If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines . Missing a feature? \u00b6 You can request a new feature by submitting an issue to our GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone. Please consider what kind of change it is: For a major feature , first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a Pull Request. However, there is no guarantee that your feature will make it into the master , as it's always a matter of opinion whether if benefits the overall functionality of the project. Submission guidelines \u00b6 Submitting an issue \u00b6 Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available.","title":"Contributing"},{"location":"contributing/#contributing","text":"Interested in contributing to RapidFuzz? Want to report a bug? Before you do, please read the following guidelines.","title":"Contributing"},{"location":"contributing/#submission-context","text":"","title":"Submission context"},{"location":"contributing/#got-a-question-or-problem","text":"For quick questions there's no need to open an issue as you can reach us on gitter.im .","title":"Got a question or problem?"},{"location":"contributing/#found-a-bug","text":"If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines .","title":"Found a bug?"},{"location":"contributing/#missing-a-feature","text":"You can request a new feature by submitting an issue to our GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone. Please consider what kind of change it is: For a major feature , first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a Pull Request. However, there is no guarantee that your feature will make it into the master , as it's always a matter of opinion whether if benefits the overall functionality of the project.","title":"Missing a feature?"},{"location":"contributing/#submission-guidelines","text":"","title":"Submission guidelines"},{"location":"contributing/#submitting-an-issue","text":"Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available.","title":"Submitting an issue"},{"location":"installation/","text":"Installation \u00b6 Python While there are several ways of install RapidFUzz, the recommended methods are either by using pip (the Python package manager) or conda (an open-source, cross-platform, package manager) with pip recommended \u00b6 RapidFuzz can be installed with pip : pip install rapidfuzz There are pre-built binaries (wheels) of RapidFuzz for MacOS (10.9 and later), Linux x86_64 and Windows. ImportError: DLL load failed If you run into this error on Windows the reason is most likely, that the Visual C++ 2019 redistributable is not installed, which is required to find C++ Libraries (The C++ 2019 version includes the 2015, 2017 and 2019 version). with conda recommended \u00b6 RapidFuzz can be installed with conda : conda install -c conda-forge rapidfuzz from git \u00b6 RapidFuzz can be directly used from [GitHub][8] by cloning the repository which might be useful when you want to work on it: git clone https://github.com/maxbachmann/rapidfuzz.git cd rapidfuzz pip install . C++ As of now it it only possible to use the sources directly by adding them to your project. There will be a version on conan in the future","title":"Installation"},{"location":"installation/#installation","text":"Python While there are several ways of install RapidFUzz, the recommended methods are either by using pip (the Python package manager) or conda (an open-source, cross-platform, package manager)","title":"Installation"},{"location":"installation/#with-pip-recommended","text":"RapidFuzz can be installed with pip : pip install rapidfuzz There are pre-built binaries (wheels) of RapidFuzz for MacOS (10.9 and later), Linux x86_64 and Windows. ImportError: DLL load failed If you run into this error on Windows the reason is most likely, that the Visual C++ 2019 redistributable is not installed, which is required to find C++ Libraries (The C++ 2019 version includes the 2015, 2017 and 2019 version).","title":"with pip recommended"},{"location":"installation/#with-conda-recommended","text":"RapidFuzz can be installed with conda : conda install -c conda-forge rapidfuzz","title":"with conda recommended"},{"location":"installation/#from-git","text":"RapidFuzz can be directly used from [GitHub][8] by cloning the repository which might be useful when you want to work on it: git clone https://github.com/maxbachmann/rapidfuzz.git cd rapidfuzz pip install . C++ As of now it it only possible to use the sources directly by adding them to your project. There will be a version on conan in the future","title":"from git"},{"location":"license/","text":"License \u00b6 RapidFuzz is licensed under the MIT license since I believe that everyone should be able to use it without being forced to adopt the GPL license. Thats why the library is based on an older version of fuzzywuzzy that was MIT licensed as well. This old version of fuzzywuzzy can be found here . MIT License \u00b6 Copyright \u00a9 2020 Max Bachmann Copyright \u00a9 2011 Adam Cohen Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"RapidFuzz is licensed under the MIT license since I believe that everyone should be able to use it without being forced to adopt the GPL license. Thats why the library is based on an older version of fuzzywuzzy that was MIT licensed as well. This old version of fuzzywuzzy can be found here .","title":"License"},{"location":"license/#mit-license","text":"Copyright \u00a9 2020 Max Bachmann Copyright \u00a9 2011 Adam Cohen Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"usage/","text":"Usage \u00b6 fuzz \u00b6 ratio \u00b6 Calculates a simple ratio between two strings. Python Parameters: s1 : str First string to compare. s2 : str Second string to compare. processor : (Union[bool, Callable]) , default None Optional callable that reformats the strings. None is use by default in fuzz.ratio and fuzz.partial_ratio . utils.default_process , which lowercases the strings and trims whitespaces, is used by default for all other fuzz.*ratio methods score_cutoff : float , default 0 , optional Optional argument for a score threshold as a float between 0 and 100. For ratio < score_cutoff , 0 is returned instead. Returns: score : float Ratio between s1 and s2 as a float between 0 and 100 > from rapidfuzz import fuzz > fuzz.ratio ( \"this is a test\" , \"this is a test!\" ) 96 .55171966552734 C++ #include \"fuzz.hpp\" using rapidfuzz :: fuzz :: ratio ; // score is 96.55171966552734 double score = rapidfuzz :: fuzz :: ratio ( \"this is a test\" , \"this is a test!\" ); partial_ratio \u00b6 Calculates the ratio of the optimal string alignment Python Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. > from rapidfuzz import fuzz > fuzz.partial_ratio ( \"this is a test\" , \"this is a test!\" ) 100 C++ #include \"fuzz.hpp\" using rapidfuzz :: fuzz :: partial_ratio ; // score is 100 double score = rapidfuzz :: fuzz :: partial_ratio ( \"this is a test\" , \"this is a test!\" ); token_sort_ratio \u00b6 Sorts the words in the strings and calculates the ratio between them. Python Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. > from rapidfuzz import fuzz > fuzz.token_sort_ratio ( \"fuzzy wuzzy was a bear\" , \"wuzzy fuzzy was a bear\" ) 100 C++ #include \"fuzz.hpp\" using rapidfuzz :: fuzz :: token_sort_ratio ; // score is 100 double score = token_sort_ratio ( \"fuzzy wuzzy was a bear\" , \"wuzzy fuzzy was a bear\" ) partial_token_sort_ratio \u00b6 Sorts the words in the strings and calculates the partial_ratio between them. Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. token_set_ratio \u00b6 Compares the words in the strings based on unique and common words between them using ratio . Python Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. > fuzz.token_sort_ratio ( \"fuzzy was a bear\" , \"fuzzy fuzzy was a bear\" ) 83 .8709716796875 > fuzz.token_set_ratio ( \"fuzzy was a bear\" , \"fuzzy fuzzy was a bear\" ) 100 .0 C++ #include \"fuzz.hpp\" using rapidfuzz :: fuzz :: token_sort_ratio ; using rapidfuzz :: fuzz :: token_set_ratio ; // score1 is 83.87 double score1 = token_sort_ratio ( \"fuzzy was a bear\" , \"fuzzy fuzzy was a bear\" ) // score2 is 100 double score2 = token_set_ratio ( \"fuzzy was a bear\" , \"fuzzy fuzzy was a bear\" ) partial_token_set_ratio \u00b6 Compares the words in the strings based on unique and common words between them using partial_ratio . Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. token_ratio \u00b6 Helper method that returns the maximum of token_set_ratio and token_sort_ratio (faster than manually executing the two functions) Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. partial_token_ratio \u00b6 Helper method that returns the maximum of partial_token_set_ratio and partial_token_sort_ratio (faster than manually executing the two functions) Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. QRatio \u00b6 Similar algorithm to ratio , but preprocesses the strings by default, while it does not do this by default in ratio . WRatio \u00b6 Calculates a weighted ratio based on the other ratio algorithms. process \u00b6 extract \u00b6 Find the best matches in a list of choices. Python Parameters: query : str String we want to find. choices : Iterable List of all strings the query should be compared with or dict with a mapping in the form of {<result>: <string to compare>} . Mapping can be anything that provides an items method like a python dict or pandas.Series (index: element) scorer : Callable , default fuzz.WRatio Optional callable that is used to calculate the matching score between the query and each choice. processor : Callable , default utils.default_process Optional callable that reformats the strings. utils.default_process is used by default, which lowercases the strings and trims whitespace limit : int Maximum amount of results to return. score_cutoff : float , default 0 Optional argument for a score threshold. Matches with a lower score than this number will not be returned. Returns: matches : List[Tuple[str, float]] or List[Tuple[str, float, str]]) Returns a list of all matches that have a score >= score_cutoff . The list will be of either (, ) when choices is a list of strings or (, , ) when choices is a mapping. > choices = [ \"Atlanta Falcons\" , \"New York Jets\" , \"New York Giants\" , \"Dallas Cowboys\" ] > process.extract ( \"new york jets\" , choices, limit = 2 ) [('new york jets', 100), ('new york giants', 78.57142639160156)] C++ #include \"process.hpp\" using rapidfuzz :: process :: extract ; // matches is a vector of std::pairs // [('new york jets', 100), ('new york giants', 78.57142639160156)] auto matches = extract ( \"new york jets\" , std :: vector < std :: string > { \"Atlanta Falcons\" , \"New York Jets\" , \"New York Giants\" , \"Dallas Cowboys\" }, utils :: default_process < char > , fuzz :: ratio < std :: string , std :: string > 2 ); extractOne \u00b6 Finds the best match in a list of choices by comparing them using the provided scorer functions. Python Parameters: Same as extract Returns: matches : Optional[Tuple[str, float]] Returns the best match in form of a tuple or None when there is no match with a score >= score_cutoff . > choices = [ \"Atlanta Falcons\" , \"New York Jets\" , \"New York Giants\" , \"Dallas Cowboys\" ] > process.extractOne ( \"cowboys\" , choices ) (\"dallas cowboys\", 90) C++ #include \"process.hpp\" using rapidfuzz :: process :: extractOne ; // matches is a boost::optional<std::pair> // (\"dallas cowboys\", 90) auto matches = extractOne ( \"cowboys\" , std :: vector < std :: string > { \"Atlanta Falcons\" , \"New York Jets\" , \"New York Giants\" , \"Dallas Cowboys\" });","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#fuzz","text":"","title":"fuzz"},{"location":"usage/#ratio","text":"Calculates a simple ratio between two strings. Python Parameters: s1 : str First string to compare. s2 : str Second string to compare. processor : (Union[bool, Callable]) , default None Optional callable that reformats the strings. None is use by default in fuzz.ratio and fuzz.partial_ratio . utils.default_process , which lowercases the strings and trims whitespaces, is used by default for all other fuzz.*ratio methods score_cutoff : float , default 0 , optional Optional argument for a score threshold as a float between 0 and 100. For ratio < score_cutoff , 0 is returned instead. Returns: score : float Ratio between s1 and s2 as a float between 0 and 100 > from rapidfuzz import fuzz > fuzz.ratio ( \"this is a test\" , \"this is a test!\" ) 96 .55171966552734 C++ #include \"fuzz.hpp\" using rapidfuzz :: fuzz :: ratio ; // score is 96.55171966552734 double score = rapidfuzz :: fuzz :: ratio ( \"this is a test\" , \"this is a test!\" );","title":"ratio"},{"location":"usage/#partial_ratio","text":"Calculates the ratio of the optimal string alignment Python Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. > from rapidfuzz import fuzz > fuzz.partial_ratio ( \"this is a test\" , \"this is a test!\" ) 100 C++ #include \"fuzz.hpp\" using rapidfuzz :: fuzz :: partial_ratio ; // score is 100 double score = rapidfuzz :: fuzz :: partial_ratio ( \"this is a test\" , \"this is a test!\" );","title":"partial_ratio"},{"location":"usage/#token_sort_ratio","text":"Sorts the words in the strings and calculates the ratio between them. Python Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. > from rapidfuzz import fuzz > fuzz.token_sort_ratio ( \"fuzzy wuzzy was a bear\" , \"wuzzy fuzzy was a bear\" ) 100 C++ #include \"fuzz.hpp\" using rapidfuzz :: fuzz :: token_sort_ratio ; // score is 100 double score = token_sort_ratio ( \"fuzzy wuzzy was a bear\" , \"wuzzy fuzzy was a bear\" )","title":"token_sort_ratio"},{"location":"usage/#partial_token_sort_ratio","text":"Sorts the words in the strings and calculates the partial_ratio between them. Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details.","title":"partial_token_sort_ratio"},{"location":"usage/#token_set_ratio","text":"Compares the words in the strings based on unique and common words between them using ratio . Python Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details. > fuzz.token_sort_ratio ( \"fuzzy was a bear\" , \"fuzzy fuzzy was a bear\" ) 83 .8709716796875 > fuzz.token_set_ratio ( \"fuzzy was a bear\" , \"fuzzy fuzzy was a bear\" ) 100 .0 C++ #include \"fuzz.hpp\" using rapidfuzz :: fuzz :: token_sort_ratio ; using rapidfuzz :: fuzz :: token_set_ratio ; // score1 is 83.87 double score1 = token_sort_ratio ( \"fuzzy was a bear\" , \"fuzzy fuzzy was a bear\" ) // score2 is 100 double score2 = token_set_ratio ( \"fuzzy was a bear\" , \"fuzzy fuzzy was a bear\" )","title":"token_set_ratio"},{"location":"usage/#partial_token_set_ratio","text":"Compares the words in the strings based on unique and common words between them using partial_ratio . Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details.","title":"partial_token_set_ratio"},{"location":"usage/#token_ratio","text":"Helper method that returns the maximum of token_set_ratio and token_sort_ratio (faster than manually executing the two functions) Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details.","title":"token_ratio"},{"location":"usage/#partial_token_ratio","text":"Helper method that returns the maximum of partial_token_set_ratio and partial_token_sort_ratio (faster than manually executing the two functions) Parameters: Same as fuzz.ratio - s1 , s2 , processor . See ratio for further details. Returns: Same as fuzz.ratio . See ratio for further details.","title":"partial_token_ratio"},{"location":"usage/#qratio","text":"Similar algorithm to ratio , but preprocesses the strings by default, while it does not do this by default in ratio .","title":"QRatio"},{"location":"usage/#wratio","text":"Calculates a weighted ratio based on the other ratio algorithms.","title":"WRatio"},{"location":"usage/#process","text":"","title":"process"},{"location":"usage/#extract","text":"Find the best matches in a list of choices. Python Parameters: query : str String we want to find. choices : Iterable List of all strings the query should be compared with or dict with a mapping in the form of {<result>: <string to compare>} . Mapping can be anything that provides an items method like a python dict or pandas.Series (index: element) scorer : Callable , default fuzz.WRatio Optional callable that is used to calculate the matching score between the query and each choice. processor : Callable , default utils.default_process Optional callable that reformats the strings. utils.default_process is used by default, which lowercases the strings and trims whitespace limit : int Maximum amount of results to return. score_cutoff : float , default 0 Optional argument for a score threshold. Matches with a lower score than this number will not be returned. Returns: matches : List[Tuple[str, float]] or List[Tuple[str, float, str]]) Returns a list of all matches that have a score >= score_cutoff . The list will be of either (, ) when choices is a list of strings or (, , ) when choices is a mapping. > choices = [ \"Atlanta Falcons\" , \"New York Jets\" , \"New York Giants\" , \"Dallas Cowboys\" ] > process.extract ( \"new york jets\" , choices, limit = 2 ) [('new york jets', 100), ('new york giants', 78.57142639160156)] C++ #include \"process.hpp\" using rapidfuzz :: process :: extract ; // matches is a vector of std::pairs // [('new york jets', 100), ('new york giants', 78.57142639160156)] auto matches = extract ( \"new york jets\" , std :: vector < std :: string > { \"Atlanta Falcons\" , \"New York Jets\" , \"New York Giants\" , \"Dallas Cowboys\" }, utils :: default_process < char > , fuzz :: ratio < std :: string , std :: string > 2 );","title":"extract"},{"location":"usage/#extractone","text":"Finds the best match in a list of choices by comparing them using the provided scorer functions. Python Parameters: Same as extract Returns: matches : Optional[Tuple[str, float]] Returns the best match in form of a tuple or None when there is no match with a score >= score_cutoff . > choices = [ \"Atlanta Falcons\" , \"New York Jets\" , \"New York Giants\" , \"Dallas Cowboys\" ] > process.extractOne ( \"cowboys\" , choices ) (\"dallas cowboys\", 90) C++ #include \"process.hpp\" using rapidfuzz :: process :: extractOne ; // matches is a boost::optional<std::pair> // (\"dallas cowboys\", 90) auto matches = extractOne ( \"cowboys\" , std :: vector < std :: string > { \"Atlanta Falcons\" , \"New York Jets\" , \"New York Giants\" , \"Dallas Cowboys\" });","title":"extractOne"}]}